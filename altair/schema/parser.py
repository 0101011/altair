"""
This contains utilities to parse the vegalite schema and output low-level
Python wrappers.
"""
import json
import os


def read_vegalite_schema():
    """Read the vega-lite schema and return as a Python dict"""
    schema_file = os.path.join(os.path.dirname(__file__),
                               'vega-lite-schema.json')
    with open(schema_file) as f:
        schema = json.load(f)

    return schema


class SchemaGen(object):
    class_template = """class {name}(T.HasTraits):\n"""
    attr_template = """    {0} = {1}\n"""

    def __init__(self, name, prop_dict, summarize_help=True):
        self.name = name
        self.prop_dict = prop_dict
        self.summarize_help = summarize_help
        self.imports = ['import traitlets as T']

    def __str__(self):
        comment = ("# This file auto-generated by "
                   "altair.schema.parser.write_files().\n"
                   "# do not modify directly.")

        code = self.class_template.format(name=self.name)
        code += ''.join(self.attr_template.format(key, self.any_attribute(val))
                       for key, val in self.prop_dict.items())

        # imports now populated; prepend them to the code
        imports = '\n'.join(self.imports)


        return "{0}\n\n{1}\n\n\n{2}\n".format(comment, imports, code)

    @staticmethod
    def format_help_string(help_str, summarize=True):
        if summarize:
            help_str = help_str.split('(e.g.')[0].split('.')[0]
        return '"""{0}."""'.format(help_str.rstrip())

    @staticmethod
    def kwds_to_str(kwds):
        vals = ', '.join("{0}={1}".format(key, val)
                         for key, val in kwds.items()
                         if key != 'help')
        if 'help' in kwds:
            vals += ', help={0}'.format(kwds['help'])
        return vals

    def any_attribute(self, attr_dict):
        if 'type' in attr_dict:
            return self.type_attribute(attr_dict)
        elif '$ref' in attr_dict:
            return self.ref_attribute(attr_dict)
        elif 'oneOf' in attr_dict:
            return self.oneof_attribute(attr_dict)
        else:
            raise NotImplementedError('unrecognized keys')

    def type_attribute(self, attr_dict):
        kwds = {}
        kwds['allow_none'] = 'True'
        kwds['default_value'] = 'None'
        if 'description' in attr_dict:
            kwds['help'] = self.format_help_string(attr_dict['description'],
                                                   summarize=self.summarize_help)

        tp = attr_dict["type"]

        if tp == "array":
            typename = self.any_attribute(attr_dict['items'])
            return "T.List({0}, {1})".format(typename, self.kwds_to_str(kwds))
        elif tp == "boolean":
            return "T.Bool({0})".format(self.kwds_to_str(kwds))
        elif tp == "number":
            if 'minimum' in attr_dict:
                kwds['min'] = attr_dict['minimum']
            if 'maximum' in attr_dict:
                kwds['max'] = attr_dict['maximum']
            return "T.CFloat({0})".format(self.kwds_to_str(kwds))
        elif tp == "string":
            return "T.Unicode({0})".format(self.kwds_to_str(kwds))
        elif tp == "object":
            return "T.Any({0})".format(self.kwds_to_str(kwds))
        else:
            raise NotImplementedError(tp)

    def ref_attribute(self, attr_dict):
        kwds = {}
        kwds['allow_none'] = 'True'
        kwds['default_value'] = 'None'
        if 'description' in attr_dict:
            kwds['help'] = self.format_help_string(attr_dict['description'],
                                                   summarize=self.summarize_help)

        pound, cls, name = attr_dict['$ref'].split('/')
        self.imports.append('from .{0} import {1}'
                            ''.format(name.lower(), name))
        return "T.Instance({0}, {1})".format(name, self.kwds_to_str(kwds))

    def oneof_attribute(self, attr_dict):
        types = (self.any_attribute(attr) for attr in attr_dict['oneOf'])
        return "T.Union([{0}])".format(', '.join(types))


def iter_classes():
    schema = read_vegalite_schema()
    for key, val in schema['definitions'].items():
        if val['type'] == 'object':
            yield key, SchemaGen(key, val['properties'])
        elif val['type'] == 'string':
            pass
        else:
            raise NotImplementedError(val['type'])


def write_files(directory=None, verbose=True):
    if directory is None:
        directory = os.path.join(os.path.dirname(__file__), '_generated')

    if verbose:
        print("writing Python schema to {0}".format(directory))
    if not os.path.exists(directory):
        if verbose:
            print("creating directory {0}".format(directory))
        os.makedirs(directory)

    if verbose:
        print("creating __init__.py")
    with open(os.path.join(directory, '__init__.py'), 'w') as f:
        f.write('"""Auto-generated Python wrappers for vegalite schema"""')

    for name, code in iter_classes():
        filename = os.path.join(directory, '{0}.py'.format(name.lower()))
        if verbose:
            print("writing {0} to {1}".format(name, filename))
        with open(filename, 'w') as f:
            f.write(str(code))
